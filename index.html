<!doctype html>
<html lang="en">

<head>
  <!-- <link rel="icon" href="data:;base64,iVBORw0KGgo="> -->
  <meta charset="utf-8">
  <title>Hello World</title>
</head>

<body>
  <div id="viz">
  </div>
  <div id="viz2">
  </div>
  <div id="viz3">

  </div>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <script>
    function getNearestMin(value) {
      const precision = 10 ** Math.floor(Math.log10(value))
      return Math.floor(value / precision) * precision
    }

    function getNearestMax(value) {
      const divisor = Math.floor(Math.log10(value))
      if (divisor === 0 || divisor === 1) {
        precision = 10
      } else {
        precision = 10 ** (divisor - 1)
      }

      return Math.ceil(value / precision) * precision
    }

    function initChart(selector, width, height, margin) {
      const chart = d3.select(selector)
        .append('svg')
        .attr('viewbox', `0 0 ${width} ${height}`)
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`)
      return chart
    }

    // global variables
    const width = 768

  </script>
  <script>
      (function () {
        const margin = { top: 200, right: 10, bottom: 30, left: 100 }
        const height = 600
        const width = 768
        const newHeight = height - margin.top - margin.bottom
        const newWidth = width - margin.left - margin.right
        const csv_url = '/data_cleaning/dummy_data_files/students_by_institution.txt'


        async function init(csvUrl) {
          const data = await d3.csv(csv_url)
          console.log(data)
          data.forEach(d => {
            d['non-degree'] = +d['non-degree']
            d.graduate = +d.graduate
            d.undergraduate = +d.undergraduate
            d.opt = +d.opt
            d.total = d['non-degree'] + d.graduate + d.undergraduate + d.opt
          })

          stackedData = ['non-degree', 'graduate', 'undergraduate', 'opt'].map(
            function (degree) {
              return data.map(d => ({ x: d[degree], y: d.institute }))
            })

          stack = d3.stack()(stackedData)

          yScale = d3.scaleBand()
            .domain(data.map(d => d.institute))
            .range([0, newHeight])

          // [min, max] = d3.extent(data, d=>d.total)
          // min = getNearestMin(min)
          // max = getNearestMax(max)
          xScale = d3.scaleLinear()
            .domain(d3.extent(data, d => d.total))
            .range([0, newWidth])

          chart = initChart('#viz3', width, height, margin)

          chart
            .append("g")
            .attr("transform", "translate(0," + newHeight + ")")
            .call(d3.axisBottom(xScale))


          chart.append('g')
            // .attr('transform', `translate(50,0)`)
            .call(d3.axisLeft(yScale))

          colors = ['red', 'yellow', 'blue', 'green']
          const colorScale = d3.scaleOrdinal()
            .domain(data.map(d => d.institute))
            .range(colors)

          console.log(stackedData)

          var groups = chart
            .append('g')
            .selectAll('g')
            .data(stackedData)
            .enter()
            .append('g')
            // .attr('class', 'ins')
            .style('fill', function (d, i) { return colors[i] })

          var rects = groups.selectAll('rect')

            .data(function (d) { console.log('here', d); return d; })
            .enter().append("rect")
            .attr("x", function (d) { console.log('x', d); return xScale(d.x); })
            .attr("y", function (d) { return yScale(d.y); })
            .attr("height", function (d) { return xScale(d.x); })
            .attr("width", yScale.bandwidth())
        }

        init()
      })()

  </script>
  <script>
    

    function getPercentage(worldData, itemValue, year) {
      for (const[key, value] of Object.entries(worldData)) {
        if ((key.slice(0, 2) + key.slice(5, 7))==year) {
          return itemValue/value*100
        }
      }

    }
    async function loadData(year, mapData) {

      data = await d3.csv('/data_cleaning/cleaned_data_files/Census-All-Places-of-Origin.csv')
      // parse all numbers
      data.forEach(d=>{
        for (const [key, value] of Object.entries(d)) {
          if (key != 'Place of Origin' && key != 'country_code') {
            d[key] = +value.replaceAll(',','')
          }
        }
      })

      // console.log('mapDisplayData', data)
      worldData = data.filter(d => d['Place of Origin'] == 'WORLD TOTAL')
      console.log(worldData)
      data = data.filter(d => d.country_code)
      console.log('mapDisplayData', data)

      data = data.map(d=>{
        let newdata = {
          'country': d['Place of Origin'],
          'country_code': d['country_code']
        }
        for (const [key, value] of Object.entries(d)) {
          if ((key.slice(0, 2) + key.slice(5, 7))==year) {
            newdata[year] = getPercentage(worldData,value,year)
          }
        }
        return newdata      

      })


      console.log('mapDisplayData', data)
      return data
    }


    mapUrl = 'https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json'
    function initMap(world) {
      var svg = d3.select("#viz2").append("svg")
        .attr('height', 400)
        .attr('width', 768)
      const projection = d3.geoMercator()
        .scale(120)
        .translate([400, 250])
        .precision(.1)


      var path = d3.geoPath().projection(projection);

      svg.selectAll("path")
        .data(topojson.feature(world, world.objects.countries).features)
        .enter().append("path")
        .attr("d", path)
        .attr('fill', '#424244')

    }

    async function loadMap(mapUrl) {
      mapData = await d3.json(mapUrl)
      mapDisplayData = await loadData('2019')
      initMap(mapData)
    }


    // Draw map
    loadMap(mapUrl)

  </script>
  <script>

    function getXScale(data, width) {
      return d3.scaleTime()
        .domain(d3.extent(data, d => d.Year))
        .range([0, width])

    }

    function getYScale(data, height) {
      [min, max] = d3.extent(data, d => d.Total)
      min = getNearestMin(min)
      max = getNearestMax(max)
      console.log('min max', min, max)

      return d3.scaleLinear()
        .domain([min, max])
        .range([height, 0])

    }

    async function init() {
      const csv_url = '/data_cleaning/cleaned_data_files/Census-Academic-Level.csv'
      const margin = { top: 30, right: 100, bottom: 30, left: 60 }
      const height = 400
      const width = 768
      const newHeight = height - margin.top - margin.bottom
      const newWidth = width - margin.left - margin.right


      data = await d3.csv(csv_url)
      data = data.filter((d, i) => i % 2 === 0)

      // data.forEach(d=>console.log(d.Year.slice(0,7)))
      // clean data
      data = data.map(d => ({
        Year: d3.timeParse('%Y')(d.Year.slice(0, 2) + d.Year.slice(5, 7)),
        Total: +d['TOTAL INTERNATIONAL STUDENTS']
      }))

      console.log('line chart data', data)
      console.log('x axis min max', d3.extent(data, d => d.Year))
      chart = initChart('#viz', width, height, margin)
      xScale = getXScale(data, newWidth)
      yScale = getYScale(data, newHeight)
      console.log(d3.extent(data, d => d.Total))

      chart
        .append("g")
        .attr("transform", "translate(0," + newHeight + ")")
        .call(d3.axisBottom(xScale))


      chart.append('g')
        // .attr('transform', `translate(50,0)`)
        .call(d3.axisLeft(yScale))

      chart.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 1.5)
        .attr("d", d3.line()
          .x(d => xScale(d.Year))
          .y(d => yScale(d.Total))
        )


      console.log(data)
    }

    init()

  </script>
</body>

</html>