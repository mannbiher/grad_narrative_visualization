<!doctype html>
<html lang="en">

<head>
  <!-- <link rel="icon" href="data:;base64,iVBORw0KGgo="> -->
  <meta charset="utf-8">
  <title>International Students in U.S.</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
    integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
<style>
  div.viz3-tooltip {
     position: absolute;
     text-align: center;
     padding: .5rem;
     background: #FFFFFF;
     color: #313639;
     border: 1px solid #313639;
     border-radius: 8px;
     pointer-events: none;
     font-size: .8rem;
}
</style>
</head>

<body>
  <div class=container>
    <h1>International Students in U.S.</h1>
    <nav>
      <ul class="pagination">
        <li class="page-item active"><a class="page-link" href="#" id="viz-link">1</a></li>
        <li class="page-item">
          <a class="page-link" href="#" id="viz2-link">2</a>
        </li>
        <li class="page-item"><a class="page-link" href="#" id="viz3-link">3</a></li>

      </ul>
    </nav>
    <div class="row">
      <select id='viz3-year'></select>
    </div>
    <div id="viz" class="row">
    </div>
    <div id="viz2" class="row" style="display: none;">
    </div>
    <div id="viz3" class="row" style="display: none;">
    </div>
  </div>




  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
  <script>
    function numberWithCommas(x) {
      return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function removeHash() {
      var scrollV, scrollH, loc = window.location;
      if ("pushState" in history)
        history.pushState("", document.title, loc.pathname + loc.search);
      else {
        // Prevent scrolling by storing the page's current scroll offset
        scrollV = document.body.scrollTop;
        scrollH = document.body.scrollLeft;

        loc.hash = "";

        // Restore the scroll offset, should be flicker free
        document.body.scrollTop = scrollV;
        document.body.scrollLeft = scrollH;
      }
    }

    function removeClass(className, classToRemove) {
      classes = className.match(/\S+/g) || []
      classes = classes.filter(d => d !== classToRemove)
      return classes.join(' ')
    }

    function addClass(className, classToAdd) {
      classes = className.match(/\S+/g) || []
      classes = classes.filter(d => d !== classToAdd)
      classes.push(classToAdd)
      return classes.join(' ')
    }

    function removeActive() {
      activeLink = d3.select('nav ul.pagination li.page-item.active')
      className = activeLink.attr('class')
      className = removeClass(className, 'active')
      activeLink.attr('class', className)
    }

    function onClick() {
      allTargetIds = ['#viz', '#viz2', '#viz3']
      targetId = '#' + d3.select(this).attr('id').slice(0, -5)

      target = d3.select(targetId)

      otherTargets = allTargetIds
        .filter(d => d !== targetId)
        .map(d => d3.select(d))
      console.log(otherTargets)

      removeActive()
      parentNode = d3.select(this.parentNode)
      parentClass = parentNode.attr('class')
      parentClass = addClass(parentClass, 'active')
      parentNode.attr('class', parentClass)

      if (target.style('display') === 'none') {
        target
          .style('display', null)

        otherTargets.forEach(d => {
          d.style('display', 'none')


        })

      }
    }
    (function () {
      vizLink = d3.select('#viz-link')
        .on('click', onClick)
      vizLink = d3.select('#viz2-link')
        .on('click', onClick)
      vizLink = d3.select('#viz3-link')
        .on('click', onClick)



    })()

    function getNearestMin(value) {
      const precision = 10 ** Math.floor(Math.log10(value))
      return Math.floor(value / precision) * precision
    }

    function getNearestMax(value) {
      const divisor = Math.floor(Math.log10(value))
      if (divisor === 0 || divisor === 1) {
        precision = 10
      } else {
        precision = 10 ** (divisor - 1)
      }

      return Math.ceil(value / precision) * precision
    }

    function initChart(selector, width, height, margin) {
      const chart = d3.select(selector)
        .append('svg')
        .attr('viewbox', `0 0 ${width} ${height}`)
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`)
      return chart
    }

    // global variables
    const width = 768

  </script>
  <script>
      (function () {
        const margin = { top: 10, right: 10, bottom: 30, left: 250 }
        const height = 400
        const width = 768
        const newHeight = height - margin.top - margin.bottom
        const newWidth = width - margin.left - margin.right
        const svgSelector = '#viz3'
        const selectSelector = '#viz3-year'
        const tooltipClass = 'viz3-tooltip'

        function getXScale(data, width) {
          return d3.scaleLinear()
            .domain([0, d3.max(data, d => d.Students)])
            .range([0, width])
        }

        function getYScale(data, height) {
          return d3.scaleBand()
            .domain(data.map(d => d.Institutions))
            .range([0, height])
            .padding(.1)

        }

        function filterData(data, year) {
          return data.filter(d => d.Year == year).slice(0, 10)

        }
        async function loadData() {
          data = await d3.csv('./data_cleaning/cleaned_data_files/Census-Top-25-Institutions.csv')
          data.forEach(d => {
            d.Rank = +d.Rank
            d.Year = d.Year.slice(0, 2) + d.Year.slice(5, 7)
            d.Students = +d["Int'l Students"].replace(/,/g, '')
            delete d["Int'l Students"]
          })

          return data


        }

        function updateSelect(selector, years) {
          select = d3.select(selector)
          years.forEach((d, i) => {

            const option = select.append('option')
              .attr('value', d)
              .text(d)
            if (i === 0) {
              option.attr('selected', 'selected')

            }
          })


        }

        function createTooltip(className) {
          return d3.select("body").append("div")
            .attr("class", className)
            .style("opacity", 0);
        }

        async function render() {
          chart = initChart(svgSelector, width, height, margin)
          origData = await loadData()
          years = origData.map(d => d.Year)
            .filter((d, i, arr) => arr.indexOf(d) === i)
            .sort((a, b) => b - a)
          selectYear = years[0]
          updateSelect(selectSelector, years)
          data = filterData(origData, selectYear)


          xScale = getXScale(data, newWidth)
          yScale = getYScale(data, newHeight)

          xAxis = chart.append('g')
            .attr('transform', `translate(0,${newHeight})`)
            .call(d3.axisBottom(xScale))

          yAxis = chart.append('g')
            .call(d3.axisLeft(yScale))

          // tooltip div
          tipDiv = createTooltip(tooltipClass)

          const bars = chart.selectAll('myrect')
            .data(data)
            .enter()
            .append('rect')
            .attr('x', xScale(0))
            .attr('y', d => yScale(d.Institutions))
            .attr('width', d => xScale(d.Students))
            .attr('height', yScale.bandwidth())
            .attr('fill', 'steelblue')
            .on('mouseover', function (d, i) {
              d3.select(this).transition()
                .duration('50')
                .attr('opacity', '.85')
              tipDiv.transition()
                .duration(50)
                .style("opacity", 1)
              
              html = `Students: ${numberWithCommas(d.Students)}`
              tipDiv.html(html)
                .style("left", (d3.event.pageX + 10) + "px")
                .style("top", (d3.event.pageY - 15) + "px");

            })
            .on('mouseout', function (d, i) {
              d3.select(this).transition()
                .duration('50')
                .attr('opacity', '1')
              tipDiv.transition()
                .duration('50')
                .style("opacity", 0);
            })
          // console.log('bars', bars)

          function onSelectUpdate(selectedValue) {
            console.log(selectedOption)
            data = filterData(origData, selectedOption)
            xScale = getXScale(data, newWidth)
            yScale = getYScale(data, newHeight)

            xAxis.transition()
              .duration(1000)
              .call(d3.axisBottom(xScale))

            yAxis.transition()
              .duration(1000)
              .call(d3.axisLeft(yScale))
            console.log(data)

            bars.data(data)
              .enter()
              .enter()
              .append('rect')
              .attr('x', xScale(0))
              .attr('y', d => yScale(d.Institutions))
              .attr('width', d => xScale(d.Students))
              .attr('height', yScale.bandwidth())
              .attr('fill', 'steelblue')


            bars.transition()
              .duration(1000)
              .attr('x', xScale(0))
              .attr('y', d => yScale(d.Institutions))
              .attr('width', d => xScale(d.Students))
              .attr('height', yScale.bandwidth())


          }

          d3.select(selectSelector).on(
            'change', function (d) {
              selectedOption = d3.select(this).property('value')
              onSelectUpdate(selectedOption)
            }
          )


        }

        render()
      })()

  </script>
  <script>
      (function () {
        function filterData(data, year) {

        }

        async function loadData(year, mapData) {

          data = await d3.csv('./data_cleaning/cleaned_data_files/Census-All-Places-of-Origin.csv')
          // parse all numbers
          data.forEach(d => {
            for (const [key, value] of Object.entries(d)) {
              if (key != 'Place of Origin' && key != 'country_code'
                && key != 'longitude' && key != 'latitude') {
                new_key = key.slice(0, 2) + key.slice(5, 7)
                d[new_key] = +value.replace(/,/g, '')
                delete d[key]
              }
            }
          })

          // console.log('mapDisplayData', data)
          worldData = data.filter(d => d['Place of Origin'] == 'WORLD TOTAL')[0]
          console.log(worldData)
          data = data.filter(d => d.country_code)
          console.log('mapDisplayData', data)

          data = data.map(d => {
            let newdata = {
              'country': d['Place of Origin'],
              'country_code': d['country_code'],
              'long': +d['longitude'],
              'lat': +d['latitude']
            }
            for (const [key, value] of Object.entries(d)) {
              if (key === year) {
                newdata[year] = value / worldData[year] * 100
              }
            }
            return newdata

          }).sort((a, b) => b[year] - a[year]).slice(0, 10)


          console.log('mapDisplayData', data)
          return data
        }


        mapUrl = 'https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json'
        function initMap(world, projection) {
          var svg = d3.select("#viz2").append("svg")
            .attr('height', 550)
            .attr('width', 900)



          var path = d3.geoPath().projection(projection);

          svg.selectAll("path")
            .data(topojson.feature(world, world.objects.countries).features)
            .enter().append("path")
            .attr("d", path)
            .attr('fill', '#bdbdbd')

          return svg

        }

        async function loadMap(mapUrl) {
          mapData = await d3.json(mapUrl)
          mapDisplayData = await loadData('2019')
          const projection = d3.geoMercator()
            .scale(152)
            .translate([400, 350])
            .precision(.1)
          svg = initMap(mapData, projection)
          var size = d3.scaleLog()
            .domain([1, 100])  // What's in the data
            .range([1, 60])  // Size in pixel

          var textScale = d3.scaleLinear()
            .domain([1, 100])
            .range([1, 10])



          svg
            .selectAll("myCircles")
            .data(mapDisplayData)
            .enter()
            .append("circle")
            .attr("cx", d => projection([d.long, d.lat])[0])
            .attr("cy", d => projection([d.long, d.lat])[1])
            .attr("r", d => size(d['2019']))
            .style("fill", "steelblue")
            // .attr("stroke", "white")
            // .attr("stroke-width", 1)
            .attr("fill-opacity", .9)

          svg
            .selectAll('mapText')
            .data(mapDisplayData)
            .enter()
            .append('text')
            .attr('x', d => projection([d.long, d.lat])[0])
            .attr('y', d => projection([d.long, d.lat])[1])
            .text(d => Math.round(d['2019']) + '%')
            .style('font-size', '14')
            .style('font-weight', 'bold')
            .style('font-family', 'sans-serif')
            .attr('text-anchor', 'middle')

        }


        // Draw map
        loadMap(mapUrl)
      })();
  </script>
  <script>
    (function () {

      function getAnnotations() {
        return [{
          'id': 'largest-increase',
          'note': {
            'label': 'Highest growth since 1980',
            'title': '10% growth'
          },
          'data': [d3.timeParse('%Y')('2014'), d3.timeParse('%Y')('2015')],
          'dx': 10,
          'dy': 10
        },
        {
          'id': 'smallest-increase',
          'note': {
            'label': 'Lowest growth since 2006',
            'title': '0.05% growth'
          },
          'data': [d3.timeParse('%Y')('2018'), d3.timeParse('%Y')('2019')],
          'dx': 10,
          'dy': 10
        }]
      }

      /** Draw a circle between two data points */
      function drawAnnotationCircle(chart, data, dataA, dataB, xScale, yScale) {
        // get cx and cy first
        firstPosx = xScale(dataA)
        secondPosx = xScale(dataB)

        valueA = data.filter(d => d.Year.getTime() === dataA.getTime())[0].Total
        valueB = data.filter(d => d.Year.getTime() === dataB.getTime())[0].Total

        firstPosy = yScale(valueA)
        secondPosy = yScale(valueB)


        radius = Math.sqrt((secondPosy - firstPosy) ** 2 + (secondPosx - firstPosx) ** 2) / 2
        console.log('annotations', firstPosx, secondPosx, firstPosy, secondPosy, radius)
        chart
          .append('g')
          .append('circle')
          .attr('cx', (secondPosx + firstPosx) / 2)
          .attr('cy', (firstPosy + secondPosy) / 2)
          .attr('r', radius)
          .attr('fill-opacity', 0)
          .attr('stroke', 'red')
          .attr('stroke-width', 1)

      }

      function drawAnnotations(chart, data, annotation, xScale, yScale) {
        [dataA, dataB] = annotation.data

      }


      function drawAnnotationPath(chart, data, dataA, dataB, xScale, yScale, color = 'red') {
        firstPosx = xScale(dataA)
        secondPosx = xScale(dataB)

        valueA = data.filter(d => d.Year.getTime() === dataA.getTime())[0].Total
        valueB = data.filter(d => d.Year.getTime() === dataB.getTime())[0].Total

        firstPosy = yScale(valueA)
        secondPosy = yScale(valueB)
        const centerPosx = (firstPosx + secondPosx) / 2
        const centerPosy = (firstPosy + secondPosy) / 2 - 20

        const txtPosx = centerPosx - 100
        const txtPosy = centerPosy - 100

        textPathData = `M ${centerPosx} ${centerPosy} ` +
          `L ${txtPosx} ${txtPosy}`

        chart.append('path')
          // .data(annotateData)
          // .enter()
          .attr('fill-opacity', 0)
          .attr("stroke", color)
          // .attr("stroke-width", 2)
          .attr("d", textPathData)

        chart.append('text')
          .attr('x', txtPosx)
          .attr('y', txtPosy)
          .text('10% growth')
          .attr('id', '')


        const ticks = d3.selectAll("#viz svg g g g.tick line")
          .attr('stroke-dasharray', (d, i) => {
            if ([4, 5, 8, 9].includes(i)) {
              return '5 5'
            }

          })
          .attr('y2', (d, i) => {
            if ([4, 5, 8, 9].includes(i)) {
              return -yScale(yScale.domain()[0])
            }
          })


        pathD = `M ${firstPosx} ${firstPosy} ` +
          `L ${secondPosx} ${secondPosy} `

        chart.append('path')
          // .data(annotateData)
          // .enter()
          .attr('fill-opacity', 0)
          .attr("stroke", color)
          .attr("stroke-width", 2)
          .attr("d", pathD)

      }

      function getXScale(data, width) {
        [min, max] = d3.extent(data, d => d.Year)
        // max =  new Date(max.setMonth(max.getMonth()+8))
        return d3.scaleTime()
          .domain([min, max])
          .range([0, width])

      }

      function getYScale(data, height) {
        [min, max] = d3.extent(data, d => d.Total)
        min = getNearestMin(min)
        max = getNearestMax(max)
        // add 50,000 more 
        max += 50000
        console.log('min max', min, max)

        return d3.scaleLinear()
          .domain([min, max])
          .range([height, 0])

      }

      function createCircle(chart) {
        return chart.append('g')
          .append('circle')
          .style("fill", "steelblue")
          .attr("stroke", "black")
          .attr('r', 8.5)
          .style("opacity", 1)
      }

      function eventCapture(chart, newWidth, newHeight, mousemove) {
        return chart.append('rect')
          .style("fill", "none")
          .style("pointer-events", "all")
          .attr('width', newWidth)
          .attr('height', newHeight)
          // .on('mouseover', mouseover)
          .on('mousemove', mousemove)
        // .on('mouseout', mouseout);

      }

      async function init() {
        const csv_url = './data_cleaning/cleaned_data_files/Census-Academic-Level.csv'
        const margin = { top: 30, right: 100, bottom: 30, left: 60 }
        const height = 500
        const width = 768
        const newHeight = height - margin.top - margin.bottom
        const newWidth = width - margin.left - margin.right


        lineData = await d3.csv(csv_url)
        lineData = lineData.filter((d, i) => i % 2 === 0)

        // clean lineData
        lineData = lineData.map((d, i, arr) => {
          totalStudents = +d['TOTAL INTERNATIONAL STUDENTS']
          newData = {
            Year: d3.timeParse('%Y')(d.Year.slice(0, 2) + d.Year.slice(5, 7)),
            Total: totalStudents
          }
          // calculate percentage increase
          if (i == 0) {
            newData.Percentage = 0
          } else {
            lastStudents = +arr[i - 1]['TOTAL INTERNATIONAL STUDENTS']
            newData.Percentage = +((totalStudents - lastStudents) / lastStudents * 100).toFixed(2)
          }
          return newData
        })



        console.log('line chart lineData', lineData)
        console.log('x axis min max', d3.extent(lineData, d => d.Year))
        chart = initChart('#viz', width, height, margin)
        xScale = getXScale(lineData, newWidth)
        yScale = getYScale(lineData, newHeight)
        console.log(d3.extent(lineData, d => d.Total))

        chart
          .append("g")
          .attr("transform", "translate(0," + newHeight + ")")
          .call(d3.axisBottom(xScale)
            // .tickSize(-newHeight)

          )


        chart.append('g')
          // .attr('transform', `translate(50,0)`)
          .call(d3.axisLeft(yScale))

        chart.append("path")
          .datum(lineData)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("d", d3.line()
            .x(d => xScale(d.Year))
            .y(d => yScale(d.Total))
          )

        annotations = getAnnotations()
        annotations.forEach(d => {
          drawAnnotationPath(chart, lineData, d.data[0],
            d.data[1], xScale, yScale)
        })

        const guide = createCircle(chart)
        const bisect = d3.bisector(d => d.x).left
        console.log('line chart lineData', lineData)
        // function mousemove() {
        //   console.log( d3.event.pageX, d3.event.pageY )
        //   const x0 = xScale.invert(d3.mouse(this)[0])
        //   var i = bisect(lineData, x0, 1)

        //   selectedData = lineData[i]

        //   guide
        //   .attr("cx", xScale(selectedData.Year))
        //   .attr("cy", yScale(selectedData.Total))

        // }

        // const eventCaptureRect = eventCapture(
        //   chart, newWidth, newHeight, mousemove)



        // console.log(data)
      }

      init()
    })()
  </script>
</body>

</html>